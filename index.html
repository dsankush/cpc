  const trim = (s)=> (s==null?'' : String(s).trim());
  const toDateKey = (dt)=>{
    if(!dt) return '';
    const s = trim(dt);
    if(!s) return '';
    
    // Handle DD-MM-YYYY HH:MM format (e.g., "15-09-2025 05:42")
    // Extract date part before the space/time
    const datePart = s.split(' ')[0];
    const parts = datePart.split('-');
    
    if(parts.length === 3){
      const day = parts[0].padStart(2, '0');
      const month = parts[1].padStart(2, '0');
      const year = parts[2];
      
      // Validate the parts are numbers
      if(!isNaN(day) && !isNaN(month) && !isNaN(year)){
        // Return in YYYY-MM-DD format
        return year + '-' + month + '-' + day;
      }
    }
    
    // Fallback: try original parsing method
    const d = new Date(s.replace(/-/g,'/'));
    if(isNaN(d)) return '';
    return d.getFullYear()+'-'+String(d.getMonth()+1).padStart(2,'0')+'-'+String(d.getDate()).padStart(2,'0');
  };
    return rows.filter(r=>{
      if(f.dateFrom || f.dateTo){
        const scanDate = toDateKey(trim(r['Scan Date']));
        
        // Exclude rows with invalid/missing dates when date filter is active
        if(!scanDate) return false;
        
        if(f.dateFrom && scanDate < f.dateFrom) return false;
        if(f.dateTo && scanDate > f.dateTo) return false;
      }
